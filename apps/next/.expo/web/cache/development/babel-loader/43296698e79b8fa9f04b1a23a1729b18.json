{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _Reanimated$default$c, _Reanimated$default;\n\nimport React, { useEffect, useRef } from 'react';\nimport { BaseGesture, CALLBACK_TYPE } from \"./gesture\";\nimport { Reanimated } from \"./reanimatedWrapper\";\nimport { registerHandler, unregisterHandler } from \"../handlersRegistry\";\nimport RNGestureHandlerModule from \"../../RNGestureHandlerModule\";\nimport { baseGestureHandlerWithMonitorProps, filterConfig, findNodeHandle } from \"../gestureHandlerCommon\";\nimport { GestureStateManager } from \"./gestureStateManager\";\nimport { flingGestureHandlerProps } from \"../FlingGestureHandler\";\nimport { forceTouchGestureHandlerProps } from \"../ForceTouchGestureHandler\";\nimport { longPressGestureHandlerProps } from \"../LongPressGestureHandler\";\nimport { panGestureHandlerProps, panGestureHandlerCustomNativeProps } from \"../PanGestureHandler\";\nimport { tapGestureHandlerProps } from \"../TapGestureHandler\";\nimport { State } from \"../../State\";\nimport { EventType } from \"../../EventType\";\nvar ALLOWED_PROPS = [].concat(_toConsumableArray(baseGestureHandlerWithMonitorProps), _toConsumableArray(tapGestureHandlerProps), _toConsumableArray(panGestureHandlerProps), _toConsumableArray(panGestureHandlerCustomNativeProps), _toConsumableArray(longPressGestureHandlerProps), _toConsumableArray(forceTouchGestureHandlerProps), _toConsumableArray(flingGestureHandlerProps));\n\nfunction convertToHandlerTag(ref) {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    var _ref$current$handlerT, _ref$current;\n\n    return (_ref$current$handlerT = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.handlerTag) !== null && _ref$current$handlerT !== void 0 ? _ref$current$handlerT : -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup) {\n  var _interactionGroup$map, _interactionGroup$map2;\n\n  return (_interactionGroup$map = interactionGroup === null || interactionGroup === void 0 ? void 0 : (_interactionGroup$map2 = interactionGroup.map(convertToHandlerTag)) === null || _interactionGroup$map2 === void 0 ? void 0 : _interactionGroup$map2.filter(function (tag) {\n    return tag > 0;\n  })) !== null && _interactionGroup$map !== void 0 ? _interactionGroup$map : [];\n}\n\nfunction dropHandlers(preparedGesture) {\n  for (var _iterator = _createForOfIteratorHelperLoose(preparedGesture.config), _step; !(_step = _iterator()).done;) {\n    var handler = _step.value;\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\n    unregisterHandler(handler.handlerTag);\n  }\n}\n\nfunction attachHandlers(_ref) {\n  var preparedGesture = _ref.preparedGesture,\n      gestureConfig = _ref.gestureConfig,\n      gesture = _ref.gesture,\n      viewTag = _ref.viewTag,\n      useAnimated = _ref.useAnimated;\n\n  if (!preparedGesture.firstExecution) {\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  setImmediate(function () {\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.prepare();\n  });\n\n  var _loop = function _loop(handler) {\n    RNGestureHandlerModule.createGestureHandler(handler.handlerName, handler.handlerTag, filterConfig(handler.config, ALLOWED_PROPS));\n    registerHandler(handler.handlerTag, handler);\n    setImmediate(function () {\n      var requireToFail = [];\n\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      var simultaneousWith = [];\n\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(handler.config.simultaneousWith);\n      }\n\n      RNGestureHandlerModule.updateGestureHandler(handler.handlerTag, filterConfig(handler.config, ALLOWED_PROPS, {\n        simultaneousHandlers: simultaneousWith,\n        waitFor: requireToFail\n      }));\n    });\n  };\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(gesture), _step2; !(_step2 = _iterator2()).done;) {\n    var handler = _step2.value;\n\n    _loop(handler);\n  }\n\n  preparedGesture.config = gesture;\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(preparedGesture.config), _step3; !(_step3 = _iterator3()).done;) {\n    var _gesture = _step3.value;\n    RNGestureHandlerModule.attachGestureHandler(_gesture.handlerTag, viewTag, !useAnimated);\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    preparedGesture.animatedHandlers.value = gesture.map(function (g) {\n      return g.handlers;\n    });\n  }\n}\n\nfunction updateHandlers(preparedGesture, gestureConfig, gesture) {\n  gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.prepare();\n\n  for (var i = 0; i < gesture.length; i++) {\n    var handler = preparedGesture.config[i];\n    gesture[i].handlerTag = handler.handlerTag;\n    gesture[i].handlers.handlerTag = handler.handlerTag;\n  }\n\n  setImmediate(function () {\n    for (var _i = 0; _i < gesture.length; _i++) {\n      var _handler = preparedGesture.config[_i];\n      _handler.config = gesture[_i].config;\n      _handler.handlers = gesture[_i].handlers;\n      _handler.handlers.handlerTag = _handler.handlerTag;\n      var requireToFail = extractValidHandlerTags(_handler.config.requireToFail);\n      var simultaneousWith = extractValidHandlerTags(_handler.config.simultaneousWith);\n      RNGestureHandlerModule.updateGestureHandler(_handler.handlerTag, filterConfig(_handler.config, ALLOWED_PROPS, {\n        simultaneousHandlers: simultaneousWith,\n        waitFor: requireToFail\n      }));\n      registerHandler(_handler.handlerTag, _handler);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = preparedGesture.config.map(function (g) {\n        return g.handlers;\n      });\n    }\n  });\n}\n\nfunction needsToReattach(preparedGesture, gesture) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n\n  for (var i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(preparedGesture) {\n  if (!Reanimated) {\n    return;\n  }\n\n  function isStateChangeEvent(event) {\n    'worklet';\n\n    return event.oldState != null;\n  }\n\n  function isTouchEvent(event) {\n    'worklet';\n\n    return event.eventType != null;\n  }\n\n  function getHandler(type, gesture) {\n    'worklet';\n\n    switch (type) {\n      case CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n\n      case CALLBACK_TYPE.START:\n        return gesture.onStart;\n\n      case CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n\n      case CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n\n      case CALLBACK_TYPE.END:\n        return gesture.onEnd;\n\n      case CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n\n      case CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n\n      case CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n\n      case CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n\n  function touchEventTypeToCallbackType(eventType) {\n    'worklet';\n\n    switch (eventType) {\n      case EventType.TOUCHES_DOWN:\n        return CALLBACK_TYPE.TOUCHES_DOWN;\n\n      case EventType.TOUCHES_MOVE:\n        return CALLBACK_TYPE.TOUCHES_MOVE;\n\n      case EventType.TOUCHES_UP:\n        return CALLBACK_TYPE.TOUCHES_UP;\n\n      case EventType.TOUCHES_CANCELLED:\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n\n    return CALLBACK_TYPE.UNDEFINED;\n  }\n\n  function runWorklet(type, gesture, event) {\n    'worklet';\n\n    var handler = getHandler(type, gesture);\n\n    if (gesture.isWorklet[type]) {\n      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        args[_key - 3] = arguments[_key];\n      }\n\n      handler === null || handler === void 0 ? void 0 : handler.apply(void 0, [event].concat(args));\n    } else if (handler) {\n      console.warn('Animated gesture callback must be a worklet');\n    }\n  }\n\n  var sharedHandlersCallbacks = Reanimated.useSharedValue(null);\n  var lastUpdateEvent = Reanimated.useSharedValue([]);\n  var stateControllers = [];\n\n  var callback = function callback(event) {\n    'worklet';\n\n    var currentCallback = sharedHandlersCallbacks.value;\n\n    if (!currentCallback) {\n      return;\n    }\n\n    for (var i = 0; i < currentCallback.length; i++) {\n      var gesture = currentCallback[i];\n\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (event.oldState === State.UNDETERMINED && event.state === State.BEGAN) {\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if ((event.oldState === State.BEGAN || event.oldState === State.UNDETERMINED) && event.state === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (event.oldState !== event.state && event.state === State.END) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n            }\n\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if ((event.state === State.FAILED || event.state === State.CANCELLED) && event.state !== event.oldState) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n            }\n\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\n          }\n\n          if (event.eventType !== EventType.UNDETERMINED) {\n            runWorklet(touchEventTypeToCallbackType(event.eventType), gesture, event, stateControllers[i]);\n          }\n        } else {\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            var _gesture$changeEventC;\n\n            runWorklet(CALLBACK_TYPE.CHANGE, gesture, (_gesture$changeEventC = gesture.changeEventCalculator) === null || _gesture$changeEventC === void 0 ? void 0 : _gesture$changeEventC.call(gesture, event, lastUpdateEvent.value[gesture.handlerTag]));\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n\n  var event = Reanimated.useEvent(callback, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], true);\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\nexport var GestureDetector = function GestureDetector(props) {\n  var _gestureConfig$toGest, _gestureConfig$toGest2;\n\n  var gestureConfig = props.gesture;\n  var gesture = (_gestureConfig$toGest = gestureConfig === null || gestureConfig === void 0 ? void 0 : (_gestureConfig$toGest2 = gestureConfig.toGestureArray) === null || _gestureConfig$toGest2 === void 0 ? void 0 : _gestureConfig$toGest2.call(gestureConfig)) !== null && _gestureConfig$toGest !== void 0 ? _gestureConfig$toGest : [];\n  var useAnimated = gesture.find(function (gesture) {\n    return gesture.handlers.isWorklet.reduce(function (prev, current) {\n      return prev || current;\n    });\n  }) != null;\n  var viewRef = useRef(null);\n  var firstRenderRef = useRef(true);\n  var preparedGesture = React.useRef({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useAnimated: useAnimated\n  }).current;\n\n  if (useAnimated !== preparedGesture.useAnimated) {\n    throw new Error('You cannot change whether you are using gesture or animatedGesture while the app is running');\n  }\n\n  if (preparedGesture.firstExecution) {\n    var _gestureConfig$initia;\n\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : (_gestureConfig$initia = gestureConfig.initialize) === null || _gestureConfig$initia === void 0 ? void 0 : _gestureConfig$initia.call(gestureConfig);\n  }\n\n  if (useAnimated) {\n    useAnimatedGesture(preparedGesture);\n  }\n\n  useEffect(function () {\n    firstRenderRef.current = true;\n    var viewTag = findNodeHandle(viewRef.current);\n    attachHandlers({\n      preparedGesture: preparedGesture,\n      gestureConfig: gestureConfig,\n      gesture: gesture,\n      viewTag: viewTag,\n      useAnimated: useAnimated\n    });\n    return function () {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n  useEffect(function () {\n    if (!firstRenderRef.current) {\n      var viewTag = findNodeHandle(viewRef.current);\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture: preparedGesture,\n          gestureConfig: gestureConfig,\n          gesture: gesture,\n          viewTag: viewTag,\n          useAnimated: useAnimated\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  if (useAnimated) {\n    return React.createElement(AnimatedWrap, {\n      ref: viewRef,\n      onGestureHandlerEvent: preparedGesture.animatedEventHandler\n    }, props.children);\n  } else {\n    return React.createElement(Wrap, {\n      ref: viewRef\n    }, props.children);\n  }\n};\n\nvar Wrap = function (_React$Component) {\n  _inherits(Wrap, _React$Component);\n\n  var _super = _createSuper(Wrap);\n\n  function Wrap() {\n    _classCallCheck(this, Wrap);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Wrap, [{\n    key: \"render\",\n    value: function render() {\n      var child = React.Children.only(this.props.children);\n      return React.cloneElement(child, {\n        collapsable: false\n      }, child.props.children);\n    }\n  }]);\n\n  return Wrap;\n}(React.Component);\n\nvar AnimatedWrap = (_Reanimated$default$c = Reanimated === null || Reanimated === void 0 ? void 0 : (_Reanimated$default = Reanimated.default) === null || _Reanimated$default === void 0 ? void 0 : _Reanimated$default.createAnimatedComponent(Wrap)) !== null && _Reanimated$default$c !== void 0 ? _Reanimated$default$c : Wrap;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,MAA3B,QAAyC,OAAzC;AACA,SAGEC,WAHF,EAKEC,aALF;AAOA,SAASC,UAAT;AACA,SAASC,eAAT,EAA0BC,iBAA1B;AACA,OAAOC,sBAAP;AACA,SACEC,kCADF,EAEEC,YAFF,EAGEC,cAHF;AAQA,SACEC,mBADF;AAIA,SAASC,wBAAT;AACA,SAASC,6BAAT;AACA,SAASC,4BAAT;AACA,SACEC,sBADF,EAEEC,kCAFF;AAIA,SAASC,sBAAT;AACA,SAASC,KAAT;AACA,SAASC,SAAT;AAGA,IAAMC,aAAa,gCACdZ,kCADc,sBAEdS,sBAFc,sBAGdF,sBAHc,sBAIdC,kCAJc,sBAKdF,4BALc,sBAMdD,6BANc,sBAOdD,wBAPc,EAAnB;;AAoBA,SAASS,mBAAT,CAA6BC,GAA7B,EAAsD;AACpD,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAOA,GAAP;AADF,SAEO,IAAIA,GAAG,YAAYpB,WAAnB,EAAgC;AACrC,WAAOoB,GAAG,CAACC,UAAX;AADK,SAEA;AAAA;;AAGL,oDAAOD,GAAG,CAACE,OAAX,iDAAOC,aAAaF,UAApB,yEAAkC,CAAC,CAAnC;AACD;AACF;;AAED,SAASG,uBAAT,CAAiCC,gBAAjC,EAA6E;AAAA;;AAC3E,kCACEA,gBADF,SACEA,oBADF,WACEA,GADF,MACEA,GADF,0BACEA,gBAAgB,CAAEC,GAAlBD,CAAsBN,mBAAtBM,CADF,2DACEE,uBAA4CC,MAA5C,CAAoDC,aAAD;AAAA,WAASA,GAAG,GAAG,CAAf;AAAA,GAAnD,CADF,yEAC0E,EAD1E;AAGD;;AAED,SAASC,YAAT,CAAsBC,eAAtB,EAA+D;AAC7D,uDAAsBA,eAAe,CAACC,MAAtC,wCAA8C;AAAA,QAAnCC,OAAmC;AAC5C5B,0BAAsB,CAAC6B,kBAAvB7B,CAA0C4B,OAAO,CAACZ,UAAlDhB;AAEAD,qBAAiB,CAAC6B,OAAO,CAACZ,UAAT,CAAjBjB;AACD;AACF;;AAUD,SAAS+B,cAAT,OAMyB;AAAA,MALvBJ,eAKuB,QALvBA,eAKuB;AAAA,MAJvBK,aAIuB,QAJvBA,aAIuB;AAAA,MAHvBC,OAGuB,QAHvBA,OAGuB;AAAA,MAFvBC,OAEuB,QAFvBA,OAEuB;AAAA,MADvBC,WACuB,QADvBA,WACuB;;AACvB,MAAI,CAACR,eAAe,CAACS,cAArB,EAAqC;AACnCJ,iBAAa,SAAbA,iBAAa,WAAbA,yBAAa,CAAEK,UAAfL;AADF,SAEO;AACLL,mBAAe,CAACS,cAAhBT,GAAiC,KAAjCA;AAJqB;;AASvBW,cAAY,CAAC,YAAM;AACjBN,iBAAa,SAAbA,iBAAa,WAAbA,yBAAa,CAAEO,OAAfP;AADU,IAAZM;;AATuB,6BAaZT,OAbY;AAcrB5B,0BAAsB,CAACuC,oBAAvBvC,CACE4B,OAAO,CAACY,WADVxC,EAEE4B,OAAO,CAACZ,UAFVhB,EAGEE,YAAY,CAAC0B,OAAO,CAACD,MAAT,EAAiBd,aAAjB,CAHdb;AAMAF,mBAAe,CAAC8B,OAAO,CAACZ,UAAT,EAAqBY,OAArB,CAAf9B;AAIAuC,gBAAY,CAAC,YAAM;AACjB,UAAII,aAAuB,GAAG,EAA9B;;AACA,UAAIb,OAAO,CAACD,MAARC,CAAea,aAAnB,EAAkC;AAChCA,qBAAa,GAAGtB,uBAAuB,CAACS,OAAO,CAACD,MAARC,CAAea,aAAhB,CAAvCA;AACD;;AAED,UAAIC,gBAA0B,GAAG,EAAjC;;AACA,UAAId,OAAO,CAACD,MAARC,CAAec,gBAAnB,EAAqC;AACnCA,wBAAgB,GAAGvB,uBAAuB,CACxCS,OAAO,CAACD,MAARC,CAAec,gBADyB,CAA1CA;AAGD;;AAED1C,4BAAsB,CAAC2C,oBAAvB3C,CACE4B,OAAO,CAACZ,UADVhB,EAEEE,YAAY,CAAC0B,OAAO,CAACD,MAAT,EAAiBd,aAAjB,EAAgC;AAC1C+B,4BAAoB,EAAEF,gBADoB;AAE1CG,eAAO,EAAEJ;AAFiC,OAAhC,CAFdzC;AAbU,MAAZqC;AAxBqB;;AAavB,wDAAsBL,OAAtB,2CAA+B;AAAA,QAApBJ,OAAoB;;AAAA,UAApBA,OAAoB;AAgC9B;;AACDF,iBAAe,CAACC,MAAhBD,GAAyBM,OAAzBN;;AAEA,wDAAsBA,eAAe,CAACC,MAAtC,2CAA8C;AAAA,QAAnCK,QAAmC;AAC5ChC,0BAAsB,CAAC8C,oBAAvB9C,CACEgC,QAAO,CAAChB,UADVhB,EAEEiC,OAFFjC,EAGE,CAACkC,WAHHlC;AAKD;;AAED,MAAI0B,eAAe,CAACqB,gBAApB,EAAsC;AACpCrB,mBAAe,CAACqB,gBAAhBrB,CAAiCsB,KAAjCtB,GAA0CM,OAAO,CAACX,GAARW,CACvCiB,WAAD;AAAA,aAAOA,CAAC,CAACC,QAAT;AAAA,KADwClB,CAA1CN;AAGD;AACF;;AAED,SAASyB,cAAT,CACEzB,eADF,EAEEK,aAFF,EAGEC,OAHF,EAIE;AACAD,eAAa,SAAbA,iBAAa,WAAbA,yBAAa,CAAEO,OAAfP;;AAEA,OAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,OAAO,CAACqB,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,QAAMxB,OAAO,GAAGF,eAAe,CAACC,MAAhBD,CAAuB0B,CAAvB1B,CAAhB;AAEAM,WAAO,CAACoB,CAAD,CAAPpB,CAAWhB,UAAXgB,GAAwBJ,OAAO,CAACZ,UAAhCgB;AACAA,WAAO,CAACoB,CAAD,CAAPpB,CAAWkB,QAAXlB,CAAoBhB,UAApBgB,GAAiCJ,OAAO,CAACZ,UAAzCgB;AAPF;;AAaAK,cAAY,CAAC,YAAM;AACjB,SAAK,IAAIe,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGpB,OAAO,CAACqB,MAA5B,EAAoCD,EAAC,EAArC,EAAyC;AACvC,UAAMxB,QAAO,GAAGF,eAAe,CAACC,MAAhBD,CAAuB0B,EAAvB1B,CAAhB;AAEAE,cAAO,CAACD,MAARC,GAAiBI,OAAO,CAACoB,EAAD,CAAPpB,CAAWL,MAA5BC;AACAA,cAAO,CAACsB,QAARtB,GAAmBI,OAAO,CAACoB,EAAD,CAAPpB,CAAWkB,QAA9BtB;AACAA,cAAO,CAACsB,QAARtB,CAAiBZ,UAAjBY,GAA8BA,QAAO,CAACZ,UAAtCY;AAEA,UAAMa,aAAa,GAAGtB,uBAAuB,CAC3CS,QAAO,CAACD,MAARC,CAAea,aAD4B,CAA7C;AAIA,UAAMC,gBAAgB,GAAGvB,uBAAuB,CAC9CS,QAAO,CAACD,MAARC,CAAec,gBAD+B,CAAhD;AAIA1C,4BAAsB,CAAC2C,oBAAvB3C,CACE4B,QAAO,CAACZ,UADVhB,EAEEE,YAAY,CAAC0B,QAAO,CAACD,MAAT,EAAiBd,aAAjB,EAAgC;AAC1C+B,4BAAoB,EAAEF,gBADoB;AAE1CG,eAAO,EAAEJ;AAFiC,OAAhC,CAFdzC;AAQAF,qBAAe,CAAC8B,QAAO,CAACZ,UAAT,EAAqBY,QAArB,CAAf9B;AACD;;AAED,QAAI4B,eAAe,CAACqB,gBAApB,EAAsC;AACpCrB,qBAAe,CAACqB,gBAAhBrB,CAAiCsB,KAAjCtB,GAA0CA,eAAe,CAACC,MAAhBD,CAAuBL,GAAvBK,CACvCuB,WAAD;AAAA,eAAOA,CAAC,CAACC,QAAT;AAAA,OADwCxB,CAA1CA;AAGD;AA/BS,IAAZW;AAiCD;;AAED,SAASiB,eAAT,CACE5B,eADF,EAEEM,OAFF,EAGE;AACA,MAAIA,OAAO,CAACqB,MAARrB,KAAmBN,eAAe,CAACC,MAAhBD,CAAuB2B,MAA9C,EAAsD;AACpD,WAAO,IAAP;AACD;;AACD,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,OAAO,CAACqB,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,QAAIpB,OAAO,CAACoB,CAAD,CAAPpB,CAAWQ,WAAXR,KAA2BN,eAAe,CAACC,MAAhBD,CAAuB0B,CAAvB1B,EAA0Bc,WAAzD,EAAsE;AACpE,aAAO,IAAP;AACD;AACF;;AAED,SAAO,KAAP;AACD;;AAED,SAASe,kBAAT,CAA4B7B,eAA5B,EAAqE;AACnE,MAAI,CAAC7B,UAAL,EAAiB;AACf;AACD;;AAED,WAAS2D,kBAAT,CACEC,KADF,EAEoC;AAClC;;AAEA,WAAOA,KAAK,CAACC,QAAND,IAAkB,IAAzB;AACD;;AAED,WAASE,YAAT,CACEF,KADF,EAE8B;AAC5B;;AACA,WAAOA,KAAK,CAACG,SAANH,IAAmB,IAA1B;AACD;;AAED,WAASI,UAAT,CACEC,IADF,EAEE9B,OAFF,EAGE;AACA;;AACA,YAAQ8B,IAAR;AACE,WAAKlE,aAAa,CAACmE,KAAnB;AACE,eAAO/B,OAAO,CAACgC,OAAf;;AACF,WAAKpE,aAAa,CAACqE,KAAnB;AACE,eAAOjC,OAAO,CAACkC,OAAf;;AACF,WAAKtE,aAAa,CAACuE,MAAnB;AACE,eAAOnC,OAAO,CAACoC,QAAf;;AACF,WAAKxE,aAAa,CAACyE,MAAnB;AACE,eAAOrC,OAAO,CAACsC,QAAf;;AACF,WAAK1E,aAAa,CAAC2E,GAAnB;AACE,eAAOvC,OAAO,CAACwC,KAAf;;AACF,WAAK5E,aAAa,CAAC6E,QAAnB;AACE,eAAOzC,OAAO,CAAC0C,UAAf;;AACF,WAAK9E,aAAa,CAAC+E,YAAnB;AACE,eAAO3C,OAAO,CAAC4C,aAAf;;AACF,WAAKhF,aAAa,CAACiF,YAAnB;AACE,eAAO7C,OAAO,CAAC8C,aAAf;;AACF,WAAKlF,aAAa,CAACmF,UAAnB;AACE,eAAO/C,OAAO,CAACgD,WAAf;;AACF,WAAKpF,aAAa,CAACqF,iBAAnB;AACE,eAAOjD,OAAO,CAACkD,kBAAf;AApBJ;AAsBD;;AAED,WAASC,4BAAT,CAAsCvB,SAAtC,EAA2E;AACzE;;AACA,YAAQA,SAAR;AACE,WAAKhD,SAAS,CAAC+D,YAAf;AACE,eAAO/E,aAAa,CAAC+E,YAArB;;AACF,WAAK/D,SAAS,CAACiE,YAAf;AACE,eAAOjF,aAAa,CAACiF,YAArB;;AACF,WAAKjE,SAAS,CAACmE,UAAf;AACE,eAAOnF,aAAa,CAACmF,UAArB;;AACF,WAAKnE,SAAS,CAACqE,iBAAf;AACE,eAAOrF,aAAa,CAACqF,iBAArB;AARJ;;AAUA,WAAOrF,aAAa,CAACwF,SAArB;AACD;;AAED,WAASC,UAAT,CACEvB,IADF,EAEE9B,OAFF,EAGEyB,KAHF,EAKE;AACA;;AACA,QAAM7B,OAAO,GAAGiC,UAAU,CAACC,IAAD,EAAO9B,OAAP,CAA1B;;AACA,QAAIA,OAAO,CAACsD,SAARtD,CAAkB8B,IAAlB9B,CAAJ,EAA6B;AAAA,wCAJ1BuD,IAI0B;AAJ1BA,YAI0B;AAAA;;AAG3B3D,aAAO,SAAPA,WAAO,WAAPA,mBAAO,MAAPA,UAAU6B,KAAV7B,SAAoB2D,IAApB3D;AAHF,WAIO,IAAIA,OAAJ,EAAa;AAClB4D,aAAO,CAACC,IAARD,CAAa,6CAAbA;AACD;AA9EgE;;AAoFnE,MAAME,uBAAuB,GAAG7F,UAAU,CAAC8F,cAAX9F,CAE9B,IAF8BA,CAAhC;AAKA,MAAM+F,eAAe,GAAG/F,UAAU,CAAC8F,cAAX9F,CAEtB,EAFsBA,CAAxB;AAKA,MAAMgG,gBAA2C,GAAG,EAApD;;AAEA,MAAMC,QAAQ,GACZrC,SADIqC,QACJrC,MADe,EAEZ;AACH;;AAEA,QAAMsC,eAAe,GAAGL,uBAAuB,CAAC1C,KAAhD;;AACA,QAAI,CAAC+C,eAAL,EAAsB;AACpB;AACD;;AAED,SAAK,IAAI3C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2C,eAAe,CAAC1C,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/C,UAAMpB,OAAO,GAAG+D,eAAe,CAAC3C,CAAD,CAA/B;;AAEA,UAAIK,KAAK,CAACzC,UAANyC,KAAqBzB,OAAO,CAAChB,UAAjC,EAA6C;AAC3C,YAAIwC,kBAAkB,CAACC,KAAD,CAAtB,EAA+B;AAC7B,cACEA,KAAK,CAACC,QAAND,KAAmB9C,KAAK,CAACqF,YAAzBvC,IACAA,KAAK,CAACwC,KAANxC,KAAgB9C,KAAK,CAACoD,KAFxB,EAGE;AACAsB,sBAAU,CAACzF,aAAa,CAACmE,KAAf,EAAsB/B,OAAtB,EAA+ByB,KAA/B,CAAV4B;AAJF,iBAKO,IACL,CAAC5B,KAAK,CAACC,QAAND,KAAmB9C,KAAK,CAACoD,KAAzBN,IACCA,KAAK,CAACC,QAAND,KAAmB9C,KAAK,CAACqF,YAD3B,KAEAvC,KAAK,CAACwC,KAANxC,KAAgB9C,KAAK,CAACuF,MAHjB,EAIL;AACAb,sBAAU,CAACzF,aAAa,CAACqE,KAAf,EAAsBjC,OAAtB,EAA+ByB,KAA/B,CAAV4B;AACAO,2BAAe,CAAC5C,KAAhB4C,CAAsB5D,OAAO,CAAChB,UAA9B4E,IAA4CO,SAA5CP;AANK,iBAOA,IACLnC,KAAK,CAACC,QAAND,KAAmBA,KAAK,CAACwC,KAAzBxC,IACAA,KAAK,CAACwC,KAANxC,KAAgB9C,KAAK,CAAC4D,GAFjB,EAGL;AACA,gBAAId,KAAK,CAACC,QAAND,KAAmB9C,KAAK,CAACuF,MAA7B,EAAqC;AACnCb,wBAAU,CAACzF,aAAa,CAAC2E,GAAf,EAAoBvC,OAApB,EAA6ByB,KAA7B,EAAoC,IAApC,CAAV4B;AACD;;AACDA,sBAAU,CAACzF,aAAa,CAAC6E,QAAf,EAAyBzC,OAAzB,EAAkCyB,KAAlC,EAAyC,IAAzC,CAAV4B;AAPK,iBAQA,IACL,CAAC5B,KAAK,CAACwC,KAANxC,KAAgB9C,KAAK,CAACyF,MAAtB3C,IAAgCA,KAAK,CAACwC,KAANxC,KAAgB9C,KAAK,CAAC0F,SAAvD,KACA5C,KAAK,CAACwC,KAANxC,KAAgBA,KAAK,CAACC,QAFjB,EAGL;AACA,gBAAID,KAAK,CAACC,QAAND,KAAmB9C,KAAK,CAACuF,MAA7B,EAAqC;AACnCb,wBAAU,CAACzF,aAAa,CAAC2E,GAAf,EAAoBvC,OAApB,EAA6ByB,KAA7B,EAAoC,KAApC,CAAV4B;AACD;;AACDA,sBAAU,CAACzF,aAAa,CAAC6E,QAAf,EAAyBzC,OAAzB,EAAkCyB,KAAlC,EAAyC,KAAzC,CAAV4B;AACD;AA7BH,eA8BO,IAAI1B,YAAY,CAACF,KAAD,CAAhB,EAAyB;AAC9B,cAAI,CAACoC,gBAAgB,CAACzC,CAAD,CAArB,EAA0B;AACxByC,4BAAgB,CAACzC,CAAD,CAAhByC,GAAsBzF,mBAAmB,CAACkG,MAApBlG,CAA2BqD,KAAK,CAACzC,UAAjCZ,CAAtByF;AACD;;AAED,cAAIpC,KAAK,CAACG,SAANH,KAAoB7C,SAAS,CAACoF,YAAlC,EAAgD;AAC9CX,sBAAU,CACRF,4BAA4B,CAAC1B,KAAK,CAACG,SAAP,CADpB,EAER5B,OAFQ,EAGRyB,KAHQ,EAIRoC,gBAAgB,CAACzC,CAAD,CAJR,CAAViC;AAMD;AAZI,eAaA;AACLA,oBAAU,CAACzF,aAAa,CAACuE,MAAf,EAAuBnC,OAAvB,EAAgCyB,KAAhC,CAAV4B;;AAEA,cAAIrD,OAAO,CAACsC,QAARtC,IAAoBA,OAAO,CAACuE,qBAAhC,EAAuD;AAAA;;AACrDlB,sBAAU,CACRzF,aAAa,CAACyE,MADN,EAERrC,OAFQ,2BAGRA,OAAO,CAACuE,qBAHA,0DAGRC,oCACE/C,KADF,EAEEmC,eAAe,CAAC5C,KAAhB4C,CAAsB5D,OAAO,CAAChB,UAA9B4E,CAFF,CAHQ,CAAVP;AASAO,2BAAe,CAAC5C,KAAhB4C,CAAsB5D,OAAO,CAAChB,UAA9B4E,IAA4CnC,KAA5CmC;AACD;AACF;AACF;AACF;AA1EH;;AA8EA,MAAMnC,KAAK,GAAG5D,UAAU,CAAC4G,QAAX5G,CACZiG,QADYjG,EAEZ,CAAC,6BAAD,EAAgC,uBAAhC,CAFYA,EAGZ,IAHYA,CAAd;AAMA6B,iBAAe,CAACgF,oBAAhBhF,GAAuC+B,KAAvC/B;AACAA,iBAAe,CAACqB,gBAAhBrB,GAAmCgE,uBAAnChE;AACD;;AAKD,OAAO,IAAMiF,eAA8D,GACzEC,SADWD,eACXC,MAD4E,EAEzE;AAAA;;AACH,MAAM7E,aAAa,GAAG6E,KAAK,CAAC5E,OAA5B;AACA,MAAMA,OAAO,4BAAGD,aAAH,SAAGA,iBAAH,WAAGA,GAAH,MAAGA,GAAH,0BAAGA,aAAa,CAAE8E,cAAlB,2DAAGC,0CAAH,yEAAwC,EAArD;AACA,MAAM5E,WAAW,GACfF,OAAO,CAAC+E,IAAR/E,CAAcA,iBAAD;AAAA,WACXA,OAAO,CAACkB,QAARlB,CAAiBsD,SAAjBtD,CAA2BgF,MAA3BhF,CAAkC,UAACiF,IAAD,EAAOhG,OAAP;AAAA,aAAmBgG,IAAI,IAAIhG,OAA3B;AAAA,KAAlCe,CADW;AAAA,GAAbA,KAEK,IAHP;AAIA,MAAMkF,OAAO,GAAGxH,MAAM,CAAC,IAAD,CAAtB;AACA,MAAMyH,cAAc,GAAGzH,MAAM,CAAC,IAAD,CAA7B;AAEA,MAAMgC,eAAe,GAAGlC,KAAK,CAACE,MAANF,CAAqC;AAC3DmC,UAAM,EAAEK,OADmD;AAE3D0E,wBAAoB,EAAE,IAFqC;AAG3D3D,oBAAgB,EAAE,IAHyC;AAI3DZ,kBAAc,EAAE,IAJ2C;AAK3DD,eAAW,EAAEA;AAL8C,GAArC1C,EAMrByB,OANH;;AAQA,MAAIiB,WAAW,KAAKR,eAAe,CAACQ,WAApC,EAAiD;AAC/C,UAAM,IAAIkF,KAAJ,CACJ,6FADI,CAAN;AAGD;;AAED,MAAI1F,eAAe,CAACS,cAApB,EAAoC;AAAA;;AAClCJ,iBAAa,SAAbA,iBAAa,WAAbA,kDAAa,CAAEK,UAAf;AACD;;AAED,MAAIF,WAAJ,EAAiB;AAIfqB,sBAAkB,CAAC7B,eAAD,CAAlB6B;AACD;;AAED9D,WAAS,CAAC,YAAM;AACd0H,kBAAc,CAAClG,OAAfkG,GAAyB,IAAzBA;AACA,QAAMlF,OAAO,GAAG9B,cAAc,CAAC+G,OAAO,CAACjG,OAAT,CAA9B;AACAa,kBAAc,CAAC;AACbJ,qBADa,EACbA,eADa;AAEbK,mBAFa,EAEbA,aAFa;AAGbC,aAHa,EAGbA,OAHa;AAIbC,aAJa,EAIbA,OAJa;AAKbC;AALa,KAAD,CAAdJ;AAQA,WAAO,YAAM;AACXL,kBAAY,CAACC,eAAD,CAAZD;AADF;AAXO,KAcN,EAdM,CAAThC;AAgBAA,WAAS,CAAC,YAAM;AACd,QAAI,CAAC0H,cAAc,CAAClG,OAApB,EAA6B;AAC3B,UAAMgB,OAAO,GAAG9B,cAAc,CAAC+G,OAAO,CAACjG,OAAT,CAA9B;;AAEA,UAAIqC,eAAe,CAAC5B,eAAD,EAAkBM,OAAlB,CAAnB,EAA+C;AAC7CP,oBAAY,CAACC,eAAD,CAAZD;AACAK,sBAAc,CAAC;AACbJ,yBADa,EACbA,eADa;AAEbK,uBAFa,EAEbA,aAFa;AAGbC,iBAHa,EAGbA,OAHa;AAIbC,iBAJa,EAIbA,OAJa;AAKbC;AALa,SAAD,CAAdJ;AAFF,aASO;AACLqB,sBAAc,CAACzB,eAAD,EAAkBK,aAAlB,EAAiCC,OAAjC,CAAdmB;AACD;AAdH,WAeO;AACLgE,oBAAc,CAAClG,OAAfkG,GAAyB,KAAzBA;AACD;AAlBM,KAmBN,CAACP,KAAD,CAnBM,CAATnH;;AAqBA,MAAIyC,WAAJ,EAAiB;AACf,WACE1C,oBAAC6H,YAAD;AACEtG,SAAG,EAAEmG,OADP;AAEEI,2BAAqB,EAAE5F,eAAe,CAACgF;AAFzC,OAGGE,KAAK,CAACW,QAHT,CADF;AADF,SAQO;AACL,WAAO/H,oBAACgI,IAAD;AAAMzG,SAAG,EAAEmG;AAAX,OAAqBN,KAAK,CAACW,QAA3B,CAAP;AACD;AApFI;;IAuFDC,I;;;;;;;;;;;;;WACJC,kBAAS;AAMP,UAAMC,KAAU,GAAGlI,KAAK,CAACmI,QAANnI,CAAeoI,IAAfpI,CAAoB,KAAKoH,KAAL,CAAWW,QAA/B/H,CAAnB;AAEA,aAAOA,KAAK,CAACqI,YAANrI,CACLkI,KADKlI,EAEL;AAAEsI,mBAAW,EAAE;AAAf,OAFKtI,EAILkI,KAAK,CAACd,KAANc,CAAYH,QAJP/H,CAAP;AAMD;;;;EAfgBA,KAAK,CAACuI,S;;AAkBzB,IAAMV,YAAY,4BAAGxH,UAAH,SAAGA,cAAH,WAAGA,GAAH,MAAGA,GAAH,uBAAGA,UAAU,CAAEmI,OAAf,wDAAGC,oBAAqBC,uBAArB,CAA6CV,IAA7C,CAAH,yEAAyDA,IAA3E","names":["React","useEffect","useRef","BaseGesture","CALLBACK_TYPE","Reanimated","registerHandler","unregisterHandler","RNGestureHandlerModule","baseGestureHandlerWithMonitorProps","filterConfig","findNodeHandle","GestureStateManager","flingGestureHandlerProps","forceTouchGestureHandlerProps","longPressGestureHandlerProps","panGestureHandlerProps","panGestureHandlerCustomNativeProps","tapGestureHandlerProps","State","EventType","ALLOWED_PROPS","convertToHandlerTag","ref","handlerTag","current","_ref$current","extractValidHandlerTags","interactionGroup","map","_interactionGroup$map2","filter","tag","dropHandlers","preparedGesture","config","handler","dropGestureHandler","attachHandlers","gestureConfig","gesture","viewTag","useAnimated","firstExecution","initialize","setImmediate","prepare","createGestureHandler","handlerName","requireToFail","simultaneousWith","updateGestureHandler","simultaneousHandlers","waitFor","attachGestureHandler","animatedHandlers","value","g","handlers","updateHandlers","i","length","needsToReattach","useAnimatedGesture","isStateChangeEvent","event","oldState","isTouchEvent","eventType","getHandler","type","BEGAN","onBegin","START","onStart","UPDATE","onUpdate","CHANGE","onChange","END","onEnd","FINALIZE","onFinalize","TOUCHES_DOWN","onTouchesDown","TOUCHES_MOVE","onTouchesMove","TOUCHES_UP","onTouchesUp","TOUCHES_CANCELLED","onTouchesCancelled","touchEventTypeToCallbackType","UNDEFINED","runWorklet","isWorklet","args","console","warn","sharedHandlersCallbacks","useSharedValue","lastUpdateEvent","stateControllers","callback","currentCallback","UNDETERMINED","state","ACTIVE","undefined","FAILED","CANCELLED","create","changeEventCalculator","_gesture$changeEventC","useEvent","animatedEventHandler","GestureDetector","props","toGestureArray","_gestureConfig$toGest2","find","reduce","prev","viewRef","firstRenderRef","Error","AnimatedWrap","onGestureHandlerEvent","children","Wrap","render","child","Children","only","cloneElement","collapsable","Component","default","_Reanimated$default","createAnimatedComponent"],"sources":["GestureDetector.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport {\n  GestureType,\n  HandlerCallbacks,\n  BaseGesture,\n  GestureRef,\n  CALLBACK_TYPE,\n} from './gesture';\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\nimport {\n  baseGestureHandlerWithMonitorProps,\n  filterConfig,\n  findNodeHandle,\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n} from '../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from './gestureStateManager';\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\nimport {\n  panGestureHandlerProps,\n  panGestureHandlerCustomNativeProps,\n} from '../PanGestureHandler';\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\nimport { State } from '../../State';\nimport { EventType } from '../../EventType';\nimport { ComposedGesture } from './gestureComposition';\n\nconst ALLOWED_PROPS = [\n  ...baseGestureHandlerWithMonitorProps,\n  ...tapGestureHandlerProps,\n  ...panGestureHandlerProps,\n  ...panGestureHandlerCustomNativeProps,\n  ...longPressGestureHandlerProps,\n  ...forceTouchGestureHandlerProps,\n  ...flingGestureHandlerProps,\n];\n\nexport type GestureConfigReference = {\n  config: GestureType[];\n  animatedEventHandler: unknown;\n  animatedHandlers: SharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  > | null;\n  firstExecution: boolean;\n  useAnimated: boolean;\n};\n\nfunction convertToHandlerTag(ref: GestureRef): number {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    // @ts-ignore in this case it should be a ref either to gesture object or\n    // a gesture handler component, in both cases handlerTag property exists\n    return ref.current?.handlerTag ?? -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\n  return (\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\n  );\n}\n\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\n  for (const handler of preparedGesture.config) {\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\n\n    unregisterHandler(handler.handlerTag);\n  }\n}\n\ninterface AttachHandlersConfig {\n  preparedGesture: GestureConfigReference;\n  gestureConfig: ComposedGesture | GestureType | undefined;\n  gesture: GestureType[];\n  viewTag: number;\n  useAnimated: boolean;\n}\n\nfunction attachHandlers({\n  preparedGesture,\n  gestureConfig,\n  gesture,\n  viewTag,\n  useAnimated,\n}: AttachHandlersConfig) {\n  if (!preparedGesture.firstExecution) {\n    gestureConfig?.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  // use setImmediate to extract handlerTags, because all refs should be initialized\n  // when it's ran\n  setImmediate(() => {\n    gestureConfig?.prepare();\n  });\n\n  for (const handler of gesture) {\n    RNGestureHandlerModule.createGestureHandler(\n      handler.handlerName,\n      handler.handlerTag,\n      filterConfig(handler.config, ALLOWED_PROPS)\n    );\n\n    registerHandler(handler.handlerTag, handler);\n\n    // use setImmediate to extract handlerTags, because all refs should be initialized\n    // when it's ran\n    setImmediate(() => {\n      let requireToFail: number[] = [];\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      let simultaneousWith: number[] = [];\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(\n          handler.config.simultaneousWith\n        );\n      }\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n    });\n  }\n  preparedGesture.config = gesture;\n\n  for (const gesture of preparedGesture.config) {\n    RNGestureHandlerModule.attachGestureHandler(\n      gesture.handlerTag,\n      viewTag,\n      !useAnimated // send direct events when using animatedGesture, device events otherwise\n    );\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    preparedGesture.animatedHandlers.value = (gesture.map(\n      (g) => g.handlers\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n  }\n}\n\nfunction updateHandlers(\n  preparedGesture: GestureConfigReference,\n  gestureConfig: ComposedGesture | GestureType | undefined,\n  gesture: GestureType[]\n) {\n  gestureConfig?.prepare();\n\n  for (let i = 0; i < gesture.length; i++) {\n    const handler = preparedGesture.config[i];\n\n    gesture[i].handlerTag = handler.handlerTag;\n    gesture[i].handlers.handlerTag = handler.handlerTag;\n  }\n\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  setImmediate(() => {\n    for (let i = 0; i < gesture.length; i++) {\n      const handler = preparedGesture.config[i];\n\n      handler.config = gesture[i].config;\n      handler.handlers = gesture[i].handlers;\n      handler.handlers.handlerTag = handler.handlerTag;\n\n      const requireToFail = extractValidHandlerTags(\n        handler.config.requireToFail\n      );\n\n      const simultaneousWith = extractValidHandlerTags(\n        handler.config.simultaneousWith\n      );\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n\n      registerHandler(handler.handlerTag, handler);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\n        (g) => g.handlers\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n    }\n  });\n}\n\nfunction needsToReattach(\n  preparedGesture: GestureConfigReference,\n  gesture: GestureType[]\n) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n  for (let i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(preparedGesture: GestureConfigReference) {\n  if (!Reanimated) {\n    return;\n  }\n\n  function isStateChangeEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureStateChangeEvent {\n    'worklet';\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n    return event.oldState != null;\n  }\n\n  function isTouchEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureTouchEvent {\n    'worklet';\n    return event.eventType != null;\n  }\n\n  function getHandler(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>\n  ) {\n    'worklet';\n    switch (type) {\n      case CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n      case CALLBACK_TYPE.START:\n        return gesture.onStart;\n      case CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n      case CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n      case CALLBACK_TYPE.END:\n        return gesture.onEnd;\n      case CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n      case CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n      case CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n      case CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\n    'worklet';\n    switch (eventType) {\n      case EventType.TOUCHES_DOWN:\n        return CALLBACK_TYPE.TOUCHES_DOWN;\n      case EventType.TOUCHES_MOVE:\n        return CALLBACK_TYPE.TOUCHES_MOVE;\n      case EventType.TOUCHES_UP:\n        return CALLBACK_TYPE.TOUCHES_UP;\n      case EventType.TOUCHES_CANCELLED:\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n    return CALLBACK_TYPE.UNDEFINED;\n  }\n\n  function runWorklet(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>,\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n    ...args: any[]\n  ) {\n    'worklet';\n    const handler = getHandler(type, gesture);\n    if (gesture.isWorklet[type]) {\n      // @ts-ignore Logic below makes sure the correct event is send to the\n      // correct handler.\n      handler?.(event, ...args);\n    } else if (handler) {\n      console.warn('Animated gesture callback must be a worklet');\n    }\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (\n            event.oldState === State.UNDETERMINED &&\n            event.state === State.BEGAN\n          ) {\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if (\n            (event.oldState === State.BEGAN ||\n              event.oldState === State.UNDETERMINED) &&\n            event.state === State.ACTIVE\n          ) {\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (\n            event.oldState !== event.state &&\n            event.state === State.END\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if (\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\n            event.state !== event.oldState\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\n          }\n\n          if (event.eventType !== EventType.UNDETERMINED) {\n            runWorklet(\n              touchEventTypeToCallbackType(event.eventType),\n              gesture,\n              event,\n              stateControllers[i]\n            );\n          }\n        } else {\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            runWorklet(\n              CALLBACK_TYPE.CHANGE,\n              gesture,\n              gesture.changeEventCalculator?.(\n                event,\n                lastUpdateEvent.value[gesture.handlerTag]\n              )\n            );\n\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    true\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\ninterface GestureDetectorProps {\n  gesture?: ComposedGesture | GestureType;\n}\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\n  props\n) => {\n  const gestureConfig = props.gesture;\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\n  const useAnimated =\n    gesture.find((gesture) =>\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\n    ) != null;\n  const viewRef = useRef(null);\n  const firstRenderRef = useRef(true);\n\n  const preparedGesture = React.useRef<GestureConfigReference>({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useAnimated: useAnimated,\n  }).current;\n\n  if (useAnimated !== preparedGesture.useAnimated) {\n    throw new Error(\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\n    );\n  }\n\n  if (preparedGesture.firstExecution) {\n    gestureConfig?.initialize?.();\n  }\n\n  if (useAnimated) {\n    // Whether animatedGesture or gesture is used shouldn't change\n    // during while an app is running\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAnimatedGesture(preparedGesture);\n  }\n\n  useEffect(() => {\n    firstRenderRef.current = true;\n    const viewTag = findNodeHandle(viewRef.current) as number;\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesture,\n      viewTag,\n      useAnimated,\n    });\n\n    return () => {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!firstRenderRef.current) {\n      const viewTag = findNodeHandle(viewRef.current) as number;\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesture,\n          viewTag,\n          useAnimated,\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  if (useAnimated) {\n    return (\n      <AnimatedWrap\n        ref={viewRef}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\n  }\n};\n\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\n  render() {\n    // I don't think that fighting with types over such a simple function is worth it\n    // The only thing it does is add 'collapsable: false' to the child component\n    // to make sure it is in the native view hierarchy so the detector can find\n    // correct viewTag to attach to.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const child: any = React.Children.only(this.props.children);\n\n    return React.cloneElement(\n      child,\n      { collapsable: false },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      child.props.children\n    );\n  }\n}\n\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\n"]},"metadata":{},"sourceType":"module"}